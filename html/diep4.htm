<!-- https://jay23606.github.io/chat-gpt-voice/html/diep4.htm -->

<!DOCTYPE html>
<html>
  <body style="margin: 0;">
    <canvas id="myCanvas"></canvas>
    <script>
      const canvas = document.getElementById("myCanvas");
      const ctx = canvas.getContext("2d");

      // Define the world properties
      const world = {
        width: 10000,
        height: 10000,
        triangleCount: 500,
        triangles: [],
      };

      // Generate random triangles in the world
      for (let i = 0; i < world.triangleCount; i++) {
        const triangle = {
          x: Math.random() * world.width,
          y: Math.random() * world.height,
          size: Math.random() * 20 + 10,
          angle: Math.random() * Math.PI * 2,
        };
        world.triangles.push(triangle);
      }

      // Define the viewport properties
      const viewport = {
        x: 0,
        y: 0,
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // Define the tank properties
      const tank = {
        x: viewport.width / 2,
        y: viewport.height / 2,
        turretWidth: 10,
        turretLength: 30,
        rotationAngle: 0,
        shooting: false,
      };

      // Define the bullet properties
      const bullet = {
        x: 0,
        y: 0,
        speed: 10,
        radius: 5,
        active: false,
      };

      // Update the position of the triangles relative to the viewport position
      const updateTriangles = () => {
        for (const triangle of world.triangles) {
          triangle.screenX = triangle.x - viewport.x;
          triangle.screenY = triangle.y - viewport.y;
          triangle.angle += 0.05;
        }
      };

      // Draw the triangles on the canvas
      const drawTriangles = () => {
        // Update the position of the triangles
        updateTriangles();

        // Draw the triangles
        ctx.fillStyle = "red";
        for (const triangle of world.triangles) {
          // Only draw triangles that are within the viewport
          if (
            triangle.screenX + triangle.size < 0 ||
            triangle.screenX > viewport.width ||
            triangle.screenY + triangle.size < 0 ||
            triangle.screenY > viewport.height
          ) {
            continue;
          }

          ctx.save();
          ctx.translate(triangle.screenX + triangle.size / 2, triangle.screenY + triangle.size / 2);
          ctx.rotate(triangle.angle);
          ctx.beginPath();
          ctx.moveTo(-triangle.size / 2, -triangle.size / 2);
          ctx.lineTo(triangle.size / 2, -triangle.size / 2);
          ctx.lineTo(0, triangle.size / 2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      };

      // Draw the tank on the canvas
      const drawTank = () => {
        // Draw the tank
        ctx.save();
        ctx.translate(tank.x, tank.y);
        ctx.rotate(tank.rotationAngle);
        ctx.fillRect(55, -10 / 2, tank.turretLength, tank.turretWidth);
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI * 2);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.restore();

        // Draw the bullet
        if (bullet.active) {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          ctx.fillStyle = "blue";
          ctx.fill();
        }
      };

      // Update the position of the bullet
      const updateBullet = () => {
        if (bullet.active) {
          bullet.x += bullet.speed * Math.cos(tank.rotationAngle);
          bullet.y += bullet.speed * Math.sin(tank.rotationAngle);

          // Check if the bullet hit a triangle
          for (let i = 0; i < world.triangles.length; i++) {
            const triangle = world.triangles[i];
            const dx = bullet.x - (triangle.screenX + triangle.size / 2);
            const dy = bullet.y - (triangle.screenY + triangle.size / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < triangle.size / 2) {
              world.triangles.splice(i, 1);
              bullet.active = false;
              break;
            }
          }

          // Check if the bullet is out of bounds
          if (
            bullet.x + bullet.radius < 0 ||
            bullet.x - bullet.radius > viewport.width ||
            bullet.y + bullet.radius < 0 ||
            bullet.y - bullet.radius > viewport.height
          ) {
            bullet.active = false;
          }
        }
      };

      // Handle shooting the bullet
      const shootBullet = () => {
        if (!bullet.active) {
          bullet.x = tank.x + tank.turretLength * Math.cos(tank.rotationAngle);
          bullet.y = tank.y + tank.turretLength * Math.sin(tank.rotationAngle);
          bullet.active = true;
        }
      };
      canvas.addEventListener("mousedown", shootBullet);

      // Update the rotation angle based on the mouse location
      canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        tank.rotationAngle = Math.atan2(
          mouseY - tank.y,
          mouseX - tank.x
        );
      });

      // Handle keyboard input for movement
      document.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "a":
            viewport.x -= 10;
            break;
          case "d":
            viewport.x += 10;
            break;
          case "w":
            viewport.y -= 10;
            break;
          case "s":
            viewport.y += 10;
            break;
        }
      });

      // Resize the canvas to fit the window size
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        viewport.width = canvas.width;
        viewport.height = canvas.height;
        tank.x = viewport.width / 2;
        tank.y = viewport.height / 2;
      };
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Draw the scene on the canvas
      const draw = () => {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw the triangles and tank
        drawTriangles();
        drawTank();

        // Update the bullet position and check for collisions
        updateBullet();
      };

      setInterval(draw, 10);
    </script>
  </body>
</html>
